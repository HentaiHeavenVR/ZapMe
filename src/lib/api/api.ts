/* tslint:disable */
/* eslint-disable */
/**
 * ZapMe
 * Open source application to control things
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * Account object, this can only retrieved for the user you are logged in as
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'profile_picture_id'?: string;
    /**
     * 
     * @type {UserOnlineStatus}
     * @memberof AccountDto
     */
    'status'?: UserOnlineStatus;
    /**
     * 
     * @type {string}
     * @memberof AccountDto
     */
    'status_text'?: string;
    /**
     * Date this account was created at
     * @type {string}
     * @memberof AccountDto
     */
    'created_at'?: string;
    /**
     * Last time this user was online
     * @type {string}
     * @memberof AccountDto
     */
    'last_online'?: string;
    /**
     * Obfuscated email of your account
     * @type {string}
     * @memberof AccountDto
     */
    'email'?: string;
    /**
     * True if email address has been verified
     * @type {boolean}
     * @memberof AccountDto
     */
    'email_verified'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AccountDto
     */
    'accepted_tos_version'?: number;
    /**
     * Id of friends this account has
     * @type {Array<string>}
     * @memberof AccountDto
     */
    'friends'?: Array<string>;
    /**
     * OAuth2 providers this account is connected to
     * @type {Array<string>}
     * @memberof AccountDto
     */
    'connected_accounts'?: Array<string>;
}


/**
 * Request sent to server to add a oauth connection to a account
 * @export
 * @interface AccountOAuthAdd
 */
export interface AccountOAuthAdd {
    /**
     * 
     * @type {string}
     * @memberof AccountOAuthAdd
     */
    'oauth_code'?: string;
}
/**
 * 
 * @export
 * @interface ApiConfig
 */
export interface ApiConfig {
    /**
     * The current version of the API
     * @type {string}
     * @memberof ApiConfig
     */
    'version'?: string;
    /**
     * The current Terms of Service version, if the user has not accepted this version, they will be prompted to accept it
     * @type {number}
     * @memberof ApiConfig
     */
    'tos_version'?: number;
    /**
     * The DSN for Sentry, used for error reporting  If this is null, Sentry reporting is disabled
     * @type {string}
     * @memberof ApiConfig
     */
    'sentry_dsn'?: string | null;
    /**
     * Trace sample rate for Sentry, used for performance monitoring
     * @type {number}
     * @memberof ApiConfig
     */
    'sentry_trace_sample_rate'?: number;
    /**
     * 
     * @type {AuthenticationConfig}
     * @memberof ApiConfig
     */
    'authentication'?: AuthenticationConfig;
    /**
     * 
     * @type {ApiDisabledFeatures}
     * @memberof ApiConfig
     */
    'disabled_features'?: ApiDisabledFeatures;
}
/**
 * 
 * @export
 * @interface ApiDisabledFeatures
 */
export interface ApiDisabledFeatures {
    /**
     * If true, WebRTC is disabled
     * @type {boolean}
     * @memberof ApiDisabledFeatures
     */
    'webrtc'?: boolean;
    /**
     * If true, WebSockets are disabled
     * @type {boolean}
     * @memberof ApiDisabledFeatures
     */
    'websockets'?: boolean;
    /**
     * List of disabled endpoints, if an endpoint is in this list, it will return a \"503 Service Unavailable\"
     * @type {Array<string>}
     * @memberof ApiDisabledFeatures
     */
    'endpoints'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AppConfig
 */
export interface AppConfig {
    /**
     * The current version of the App, if the local version is lower than this, the user will be notified of an update
     * @type {string}
     * @memberof AppConfig
     */
    'version'?: string;
}
/**
 * Message sent to server to authenticate user using username and password
 * @export
 * @interface AuthSignIn
 */
export interface AuthSignIn {
    /**
     * Username or email address
     * @type {string}
     * @memberof AuthSignIn
     */
    'username'?: string;
    /**
     * Password
     * @type {string}
     * @memberof AuthSignIn
     */
    'password'?: string;
    /**
     * Session name to remember this sign in by, e.g. \"My home computer\"  This is for the users to be able to see which devices they have logged in their user settings
     * @type {string}
     * @memberof AuthSignIn
     */
    'sessionName'?: string | null;
    /**
     * Make this login persist for a longer period of time
     * @type {boolean}
     * @memberof AuthSignIn
     */
    'rememberMe'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticationConfig
 */
export interface AuthenticationConfig {
    /**
     * Google Client ID for OAuth, if null, Google login will be disabled
     * @type {string}
     * @memberof AuthenticationConfig
     */
    'google_client_id'?: string | null;
    /**
     * Github Client ID for OAuth, if null, Github login will be disabled
     * @type {string}
     * @memberof AuthenticationConfig
     */
    'github_client_id'?: string | null;
    /**
     * ReCaptcha Client ID for bot detection, if null, ReCaptcha will be disabled
     * @type {string}
     * @memberof AuthenticationConfig
     */
    'recaptcha_site_key'?: string | null;
}
/**
 * 
 * @export
 * @interface CommunityConfig
 */
export interface CommunityConfig {
    /**
     * Invite uri to the community discord server
     * @type {string}
     * @memberof CommunityConfig
     */
    'discord_invite_uri'?: string;
    /**
     * Social media links to project founder\'s accounts
     * @type {Array<SocialEntry>}
     * @memberof CommunityConfig
     */
    'socials'?: Array<SocialEntry>;
}
/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * Name of the product, e.g. \"ZapMe\"
     * @type {string}
     * @memberof Config
     */
    'name'?: string;
    /**
     * 
     * @type {AppConfig}
     * @memberof Config
     */
    'app'?: AppConfig;
    /**
     * 
     * @type {ApiConfig}
     * @memberof Config
     */
    'api'?: ApiConfig;
    /**
     * 
     * @type {ContactConfig}
     * @memberof Config
     */
    'contact'?: ContactConfig;
    /**
     * 
     * @type {CommunityConfig}
     * @memberof Config
     */
    'community'?: CommunityConfig;
}
/**
 * 
 * @export
 * @interface ContactConfig
 */
export interface ContactConfig {
    /**
     * 
     * @type {string}
     * @memberof ContactConfig
     */
    'support'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactConfig
     */
    'contact'?: string;
}
/**
 * Message sent to server to create a new account
 * @export
 * @interface Create
 */
export interface Create {
    /**
     * 
     * @type {string}
     * @memberof Create
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof Create
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof Create
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof Create
     */
    'acceptedTosVersion'?: number;
    /**
     * Response from google recaptcha request
     * @type {string}
     * @memberof Create
     */
    'recaptcha_response'?: string;
}
/**
 * Details about the error
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
    /**
     * Title for developer to understand what went wrong (not user friendly)
     * @type {string}
     * @memberof ErrorDetails
     */
    'title'?: string;
    /**
     * More detailed description of what this error is about (not user friendly)
     * @type {string}
     * @memberof ErrorDetails
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetails
     */
    'traceId'?: string;
    /**
     * Suggestion to developer on how they might be able to midegate this error
     * @type {string}
     * @memberof ErrorDetails
     */
    'suggestion'?: string | null;
    /**
     * Errors for specific fields in the request
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ErrorDetails
     */
    'fields'?: { [key: string]: Array<string>; } | null;
    /**
     * 
     * @type {UserNotification}
     * @memberof ErrorDetails
     */
    'notification'?: UserNotification;
}
/**
 * List of incoming and outgoing friendrequests
 * @export
 * @interface FriendRequestList
 */
export interface FriendRequestList {
    /**
     * UserId\'s of users that has sent friend requests to this account
     * @type {Array<string>}
     * @memberof FriendRequestList
     */
    'incoming'?: Array<string>;
    /**
     * UserId\'s of users that this account has sent friend requests to
     * @type {Array<string>}
     * @memberof FriendRequestList
     */
    'outgoing'?: Array<string>;
}
/**
 * The source of an icon, this is used to determine how to fetch the icon  - uri: The icon is a URI to an image  - emoji: The icon is an emoji  - google: The icon is a Google Material Design icon name (https://fonts.google.com/icons)
 * @export
 * @enum {string}
 */

export const IconSource = {
    uri: 'uri',
    emoji: 'emoji',
    googleMaterialDesign: 'googleMaterialDesign'
} as const;

export type IconSource = typeof IconSource[keyof typeof IconSource];


/**
 * 
 * @export
 * @interface OAuthProviderList
 */
export interface OAuthProviderList {
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuthProviderList
     */
    'providers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
}
/**
 * Request sent to server to commit a password reset
 * @export
 * @interface RecoveryConfirm
 */
export interface RecoveryConfirm {
    /**
     * The new password to set
     * @type {string}
     * @memberof RecoveryConfirm
     */
    'new_password'?: string;
    /**
     * The token sent to the user\'s email address
     * @type {string}
     * @memberof RecoveryConfirm
     */
    'token'?: string;
}
/**
 * Request sent to server to request a password reset token
 * @export
 * @interface RecoveryRequest
 */
export interface RecoveryRequest {
    /**
     * Email of your account you want to recover
     * @type {string}
     * @memberof RecoveryRequest
     */
    'email'?: string;
    /**
     * Response from google recaptcha request
     * @type {string}
     * @memberof RecoveryRequest
     */
    'recaptcha_response'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SeverityLevel = {
    info: 'info',
    warning: 'warning',
    error: 'error'
} as const;

export type SeverityLevel = typeof SeverityLevel[keyof typeof SeverityLevel];


/**
 * 
 * @export
 * @interface SignInOk
 */
export interface SignInOk {
    /**
     * 
     * @type {string}
     * @memberof SignInOk
     */
    'sessionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInOk
     */
    'issuedAtUtc'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignInOk
     */
    'expiresAtUtc'?: string;
}
/**
 * 
 * @export
 * @interface SocialEntry
 */
export interface SocialEntry {
    /**
     * The name of the social platform
     * @type {string}
     * @memberof SocialEntry
     */
    'name'?: string;
    /**
     * Uri to the target page on the platform
     * @type {string}
     * @memberof SocialEntry
     */
    'uri'?: string;
    /**
     * 
     * @type {IconSource}
     * @memberof SocialEntry
     */
    'icon_type'?: IconSource;
    /**
     * The icon URI, fetched from source defined by ZapMe.Controllers.Api.V1.Config.Models.SocialEntry.IconSource
     * @type {string}
     * @memberof SocialEntry
     */
    'icon'?: string;
}


/**
 * Request sent to server to update account email address
 * @export
 * @interface UpdateEmail
 */
export interface UpdateEmail {
    /**
     * 
     * @type {string}
     * @memberof UpdateEmail
     */
    'new_email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEmail
     */
    'password'?: string;
}
/**
 * Request sent to server to update account password
 * @export
 * @interface UpdatePassword
 */
export interface UpdatePassword {
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    'new'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePassword
     */
    'old'?: string;
}
/**
 * Request sent to server to update account username
 * @export
 * @interface UpdateUserName
 */
export interface UpdateUserName {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserName
     */
    'new_username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserName
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'profile_picture_id'?: string;
    /**
     * 
     * @type {UserOnlineStatus}
     * @memberof UserDto
     */
    'status'?: UserOnlineStatus;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'status_text'?: string;
    /**
     * Date this account was created at
     * @type {string}
     * @memberof UserDto
     */
    'created_at'?: string;
    /**
     * Last time this user was online
     * @type {string}
     * @memberof UserDto
     */
    'last_online'?: string;
}


/**
 * System notification to be displayed to the user, do not confuse with user notifications  This is a hint and clients can choose to ignore it or implement notifications to be independent of this
 * @export
 * @interface UserNotification
 */
export interface UserNotification {
    /**
     * 
     * @type {SeverityLevel}
     * @memberof UserNotification
     */
    'severity'?: SeverityLevel;
    /**
     * Message title to display to the user
     * @type {string}
     * @memberof UserNotification
     */
    'title'?: string;
    /**
     * User friendly message about this notification
     * @type {string}
     * @memberof UserNotification
     */
    'message'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserOnlineStatus = {
    offline: 'offline',
    doNotDisturb: 'doNotDisturb',
    inactive: 'inactive',
    online: 'online',
    downBad: 'downBad'
} as const;

export type UserOnlineStatus = typeof UserOnlineStatus[keyof typeof UserOnlineStatus];


/**
 * Message sent to server to report a user
 * @export
 * @interface UserReport
 */
export interface UserReport {
    /**
     * 
     * @type {string}
     * @memberof UserReport
     */
    'user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserReport
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserReport
     */
    'explenation'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Complete the password reset request using the token that was received in the users email
         * @param {RecoveryConfirm} [recoveryConfirm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRecoveryConfirm: async (recoveryConfirm?: RecoveryConfirm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account/recover-confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoveryConfirm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request password recovery of a account, a recovery email will be sent to the user that makes a call to the /recovery-confirm endpoint
         * @param {RecoveryRequest} [recoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRecoveryRequest: async (recoveryRequest?: RecoveryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account/recover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a oauth connection to account
         * @param {string} providerName 
         * @param {AccountOAuthAdd} [accountOAuthAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOAuthProvider: async (providerName: string, accountOAuthAdd?: AccountOAuthAdd, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('addOAuthProvider', 'providerName', providerName)
            const localVarPath = `/api/v1/Account/oauth/{providerName}`
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountOAuthAdd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new account
         * @param {Create} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (create?: Create, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(create, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete currently logged in account
         * @param {string} [password] 
         * @param {string} [reason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (password?: string, reason?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (password != null) {
                localVarHeaderParameter['password'] = String(password);
            }

            if (reason != null) {
                localVarHeaderParameter['reason'] = String(reason);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a oauth connection from account
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOAuthProvider: async (providerName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerName' is not null or undefined
            assertParamExists('removeOAuthProvider', 'providerName', providerName)
            const localVarPath = `/api/v1/Account/oauth/{providerName}`
                .replace(`{${"providerName"}}`, encodeURIComponent(String(providerName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the account email
         * @param {UpdateEmail} [updateEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmail: async (updateEmail?: UpdateEmail, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the account password
         * @param {UpdatePassword} [updatePassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword: async (updatePassword?: UpdatePassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the account username
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfilePicture: async (body: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateProfilePicture', 'body', body)
            const localVarPath = `/api/v1/Account/pfp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'image/png';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the account username
         * @param {UpdateUserName} [updateUserName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserName: async (updateUserName?: UpdateUserName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/Account/username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Complete the password reset request using the token that was received in the users email
         * @param {RecoveryConfirm} [recoveryConfirm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountRecoveryConfirm(recoveryConfirm?: RecoveryConfirm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountRecoveryConfirm(recoveryConfirm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request password recovery of a account, a recovery email will be sent to the user that makes a call to the /recovery-confirm endpoint
         * @param {RecoveryRequest} [recoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountRecoveryRequest(recoveryRequest?: RecoveryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountRecoveryRequest(recoveryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a oauth connection to account
         * @param {string} providerName 
         * @param {AccountOAuthAdd} [accountOAuthAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOAuthProvider(providerName: string, accountOAuthAdd?: AccountOAuthAdd, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOAuthProvider(providerName, accountOAuthAdd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new account
         * @param {Create} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(create?: Create, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(create, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete currently logged in account
         * @param {string} [password] 
         * @param {string} [reason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(password?: string, reason?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(password, reason, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a oauth connection from account
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOAuthProvider(providerName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOAuthProvider(providerName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the account email
         * @param {UpdateEmail} [updateEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmail(updateEmail?: UpdateEmail, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmail(updateEmail, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the account password
         * @param {UpdatePassword} [updatePassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword(updatePassword?: UpdatePassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(updatePassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the account username
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfilePicture(body: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfilePicture(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates the account username
         * @param {UpdateUserName} [updateUserName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserName(updateUserName?: UpdateUserName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserName(updateUserName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Complete the password reset request using the token that was received in the users email
         * @param {RecoveryConfirm} [recoveryConfirm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRecoveryConfirm(recoveryConfirm?: RecoveryConfirm, options?: any): AxiosPromise<void> {
            return localVarFp.accountRecoveryConfirm(recoveryConfirm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request password recovery of a account, a recovery email will be sent to the user that makes a call to the /recovery-confirm endpoint
         * @param {RecoveryRequest} [recoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountRecoveryRequest(recoveryRequest?: RecoveryRequest, options?: any): AxiosPromise<void> {
            return localVarFp.accountRecoveryRequest(recoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a oauth connection to account
         * @param {string} providerName 
         * @param {AccountOAuthAdd} [accountOAuthAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOAuthProvider(providerName: string, accountOAuthAdd?: AccountOAuthAdd, options?: any): AxiosPromise<void> {
            return localVarFp.addOAuthProvider(providerName, accountOAuthAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new account
         * @param {Create} [create] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(create?: Create, options?: any): AxiosPromise<void> {
            return localVarFp.createAccount(create, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete currently logged in account
         * @param {string} [password] 
         * @param {string} [reason] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(password?: string, reason?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccount(password, reason, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(options?: any): AxiosPromise<AccountDto> {
            return localVarFp.getAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a oauth connection from account
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOAuthProvider(providerName: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOAuthProvider(providerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the account email
         * @param {UpdateEmail} [updateEmail] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmail(updateEmail?: UpdateEmail, options?: any): AxiosPromise<AccountDto> {
            return localVarFp.updateEmail(updateEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the account password
         * @param {UpdatePassword} [updatePassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword(updatePassword?: UpdatePassword, options?: any): AxiosPromise<AccountDto> {
            return localVarFp.updatePassword(updatePassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the account username
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfilePicture(body: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfilePicture(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the account username
         * @param {UpdateUserName} [updateUserName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserName(updateUserName?: UpdateUserName, options?: any): AxiosPromise<AccountDto> {
            return localVarFp.updateUserName(updateUserName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - interface
 * @export
 * @interface AccountApi
 */
export interface AccountApiInterface {
    /**
     * 
     * @summary Complete the password reset request using the token that was received in the users email
     * @param {RecoveryConfirm} [recoveryConfirm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountRecoveryConfirm(recoveryConfirm?: RecoveryConfirm, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Request password recovery of a account, a recovery email will be sent to the user that makes a call to the /recovery-confirm endpoint
     * @param {RecoveryRequest} [recoveryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    accountRecoveryRequest(recoveryRequest?: RecoveryRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add a oauth connection to account
     * @param {string} providerName 
     * @param {AccountOAuthAdd} [accountOAuthAdd] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    addOAuthProvider(providerName: string, accountOAuthAdd?: AccountOAuthAdd, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create a new account
     * @param {Create} [create] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    createAccount(create?: Create, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete currently logged in account
     * @param {string} [password] 
     * @param {string} [reason] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    deleteAccount(password?: string, reason?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    getAccount(options?: AxiosRequestConfig): AxiosPromise<AccountDto>;

    /**
     * 
     * @summary Remove a oauth connection from account
     * @param {string} providerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    removeOAuthProvider(providerName: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Updates the account email
     * @param {UpdateEmail} [updateEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    updateEmail(updateEmail?: UpdateEmail, options?: AxiosRequestConfig): AxiosPromise<AccountDto>;

    /**
     * 
     * @summary Updates the account password
     * @param {UpdatePassword} [updatePassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    updatePassword(updatePassword?: UpdatePassword, options?: AxiosRequestConfig): AxiosPromise<AccountDto>;

    /**
     * 
     * @summary Updates the account username
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    updateProfilePicture(body: File, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Updates the account username
     * @param {UpdateUserName} [updateUserName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApiInterface
     */
    updateUserName(updateUserName?: UpdateUserName, options?: AxiosRequestConfig): AxiosPromise<AccountDto>;

}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI implements AccountApiInterface {
    /**
     * 
     * @summary Complete the password reset request using the token that was received in the users email
     * @param {RecoveryConfirm} [recoveryConfirm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountRecoveryConfirm(recoveryConfirm?: RecoveryConfirm, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountRecoveryConfirm(recoveryConfirm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request password recovery of a account, a recovery email will be sent to the user that makes a call to the /recovery-confirm endpoint
     * @param {RecoveryRequest} [recoveryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountRecoveryRequest(recoveryRequest?: RecoveryRequest, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).accountRecoveryRequest(recoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a oauth connection to account
     * @param {string} providerName 
     * @param {AccountOAuthAdd} [accountOAuthAdd] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public addOAuthProvider(providerName: string, accountOAuthAdd?: AccountOAuthAdd, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).addOAuthProvider(providerName, accountOAuthAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new account
     * @param {Create} [create] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public createAccount(create?: Create, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).createAccount(create, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete currently logged in account
     * @param {string} [password] 
     * @param {string} [reason] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public deleteAccount(password?: string, reason?: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).deleteAccount(password, reason, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getAccount(options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).getAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a oauth connection from account
     * @param {string} providerName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public removeOAuthProvider(providerName: string, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).removeOAuthProvider(providerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the account email
     * @param {UpdateEmail} [updateEmail] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateEmail(updateEmail?: UpdateEmail, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).updateEmail(updateEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the account password
     * @param {UpdatePassword} [updatePassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updatePassword(updatePassword?: UpdatePassword, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).updatePassword(updatePassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the account username
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateProfilePicture(body: File, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).updateProfilePicture(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the account username
     * @param {UpdateUserName} [updateUserName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public updateUserName(updateUserName?: UpdateUserName, options?: AxiosRequestConfig) {
        return AccountApiFp(this.configuration).updateUserName(updateUserName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGetOAuthProviders: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/oauth-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {AuthSignIn} [authSignIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignIn: async (authSignIn?: AuthSignIn, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSignIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignInOAuth: async (provider?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/oauth-signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignOut: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/signout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGetOAuthProviders(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuthProviderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGetOAuthProviders(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {AuthSignIn} [authSignIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignIn(authSignIn?: AuthSignIn, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignIn(authSignIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignInOAuth(provider?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInOk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignInOAuth(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignOut(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignOut(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGetOAuthProviders(options?: any): AxiosPromise<OAuthProviderList> {
            return localVarFp.authGetOAuthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {AuthSignIn} [authSignIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignIn(authSignIn?: AuthSignIn, options?: any): AxiosPromise<SignInOk> {
            return localVarFp.authSignIn(authSignIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} [provider] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignInOAuth(provider?: string, options?: any): AxiosPromise<SignInOk> {
            return localVarFp.authSignInOAuth(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignOut(options?: any): AxiosPromise<void> {
            return localVarFp.authSignOut(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authGetOAuthProviders(options?: AxiosRequestConfig): AxiosPromise<OAuthProviderList>;

    /**
     * 
     * @summary 
     * @param {AuthSignIn} [authSignIn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authSignIn(authSignIn?: AuthSignIn, options?: AxiosRequestConfig): AxiosPromise<SignInOk>;

    /**
     * 
     * @summary 
     * @param {string} [provider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authSignInOAuth(provider?: string, options?: AxiosRequestConfig): AxiosPromise<SignInOk>;

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authSignOut(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authGetOAuthProviders(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authGetOAuthProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {AuthSignIn} [authSignIn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authSignIn(authSignIn?: AuthSignIn, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authSignIn(authSignIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} [provider] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authSignInOAuth(provider?: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authSignInOAuth(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authSignOut(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authSignOut(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(options?: any): AxiosPromise<Config> {
            return localVarFp.getConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConfigApi - interface
 * @export
 * @interface ConfigApi
 */
export interface ConfigApiInterface {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApiInterface
     */
    getConfig(options?: AxiosRequestConfig): AxiosPromise<Config>;

}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI implements ConfigApiInterface {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getConfig(options?: AxiosRequestConfig) {
        return ConfigApiFp(this.configuration).getConfig(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: any): AxiosPromise<void> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - interface
 * @export
 * @interface HealthApi
 */
export interface HealthApiInterface {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    getHealth(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI implements HealthApiInterface {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealth(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept incoming friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('acceptFriendRequest', 'userId', userId)
            const localVarPath = `/api/v1/user/i/{userId}/friendrequest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete outgoing/Reject incoming friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyFriendRequest: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('denyFriendRequest', 'userId', userId)
            const localVarPath = `/api/v1/user/i/{userId}/friendrequest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/api/v1/user/i/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all incoming and outgoing friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFriendRequests: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/friendrequests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Look up user by name
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookUpUser: async (userName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('lookUpUser', 'userName', userName)
            const localVarPath = `/api/v1/user/u/{userName}`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Report a user
         * @param {UserReport} [userReport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportUser: async (userReport?: UserReport, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/report`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFriendRequest: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendFriendRequest', 'userId', userId)
            const localVarPath = `/api/v1/user/i/{userId}/friendrequest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept incoming friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptFriendRequest(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptFriendRequest(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete outgoing/Reject incoming friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async denyFriendRequest(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.denyFriendRequest(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all incoming and outgoing friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFriendRequests(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FriendRequestList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFriendRequests(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Look up user by name
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookUpUser(userName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookUpUser(userName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Report a user
         * @param {UserReport} [userReport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportUser(userReport?: UserReport, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportUser(userReport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFriendRequest(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendFriendRequest(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept incoming friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptFriendRequest(userId: string, options?: any): AxiosPromise<UserDto> {
            return localVarFp.acceptFriendRequest(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete outgoing/Reject incoming friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        denyFriendRequest(userId: string, options?: any): AxiosPromise<UserDto> {
            return localVarFp.denyFriendRequest(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: string, options?: any): AxiosPromise<UserDto> {
            return localVarFp.getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all incoming and outgoing friend requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFriendRequests(options?: any): AxiosPromise<FriendRequestList> {
            return localVarFp.listFriendRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Look up user by name
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookUpUser(userName: string, options?: any): AxiosPromise<UserDto> {
            return localVarFp.lookUpUser(userName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Report a user
         * @param {UserReport} [userReport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportUser(userReport?: UserReport, options?: any): AxiosPromise<void> {
            return localVarFp.reportUser(userReport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send friend request
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFriendRequest(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sendFriendRequest(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary Accept incoming friend request
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    acceptFriendRequest(userId: string, options?: AxiosRequestConfig): AxiosPromise<UserDto>;

    /**
     * 
     * @summary Delete outgoing/Reject incoming friend request
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    denyFriendRequest(userId: string, options?: AxiosRequestConfig): AxiosPromise<UserDto>;

    /**
     * 
     * @summary Get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUser(userId: string, options?: AxiosRequestConfig): AxiosPromise<UserDto>;

    /**
     * 
     * @summary List all incoming and outgoing friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    listFriendRequests(options?: AxiosRequestConfig): AxiosPromise<FriendRequestList>;

    /**
     * 
     * @summary Look up user by name
     * @param {string} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    lookUpUser(userName: string, options?: AxiosRequestConfig): AxiosPromise<UserDto>;

    /**
     * 
     * @summary Report a user
     * @param {UserReport} [userReport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    reportUser(userReport?: UserReport, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Send friend request
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    sendFriendRequest(userId: string, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary Accept incoming friend request
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public acceptFriendRequest(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).acceptFriendRequest(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete outgoing/Reject incoming friend request
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public denyFriendRequest(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).denyFriendRequest(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all incoming and outgoing friend requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public listFriendRequests(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).listFriendRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Look up user by name
     * @param {string} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public lookUpUser(userName: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).lookUpUser(userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Report a user
     * @param {UserReport} [userReport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public reportUser(userReport?: UserReport, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).reportUser(userReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send friend request
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public sendFriendRequest(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).sendFriendRequest(userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebSocketApi - axios parameter creator
 * @export
 */
export const WebSocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Websocket endpoint for pub/sub communication (e.g. chat, notifications, events)    Documentation:  Yes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebSocketApi - functional programming interface
 * @export
 */
export const WebSocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebSocketApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Websocket endpoint for pub/sub communication (e.g. chat, notifications, events)    Documentation:  Yes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebSocketApi - factory interface
 * @export
 */
export const WebSocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebSocketApiFp(configuration)
    return {
        /**
         * 
         * @summary Websocket endpoint for pub/sub communication (e.g. chat, notifications, events)    Documentation:  Yes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wsGet(options?: any): AxiosPromise<void> {
            return localVarFp.wsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebSocketApi - interface
 * @export
 * @interface WebSocketApi
 */
export interface WebSocketApiInterface {
    /**
     * 
     * @summary Websocket endpoint for pub/sub communication (e.g. chat, notifications, events)    Documentation:  Yes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebSocketApiInterface
     */
    wsGet(options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * WebSocketApi - object-oriented interface
 * @export
 * @class WebSocketApi
 * @extends {BaseAPI}
 */
export class WebSocketApi extends BaseAPI implements WebSocketApiInterface {
    /**
     * 
     * @summary Websocket endpoint for pub/sub communication (e.g. chat, notifications, events)    Documentation:  Yes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebSocketApi
     */
    public wsGet(options?: AxiosRequestConfig) {
        return WebSocketApiFp(this.configuration).wsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


